/* ========================================================================
 * Bootstrap: carousel.js v3.3.7
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.7'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.7
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.7'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
// 
// Topic: Note for non-jQuery users
// 
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
// 
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().

(function(window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Since jQuery really isn't required for this plugin, use `jQuery` as the
  // namespace only if it already exists, otherwise use the `Cowboy` namespace,
  // creating it if necessary.
  var $ = window.jQuery || window.Cowboy || ( window.Cowboy = {} ),
    
    // Internal method reference.
    jq_throttle;
  
  // Method: jQuery.throttle
  // 
  // Throttle execution of a function. Especially useful for rate limiting
  // execution of handlers on events like resize and scroll. If you want to
  // rate-limit execution of a function to a single time, see the
  // <jQuery.debounce> method.
  // 
  // In this visualization, | is a throttled-function call and X is the actual
  // callback execution:
  // 
  // > Throttled with `no_trailing` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X    X        X    X    X    X    X    X
  // > 
  // > Throttled with `no_trailing` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X             X    X    X    X    X
  // 
  // Usage:
  // 
  // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
  // > 
  // > jQuery('selector').bind( 'someevent', throttled );
  // > jQuery('selector').unbind( 'someevent', throttled );
  // 
  // This also works in jQuery 1.4+:
  // 
  // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  // 
  // Arguments:
  // 
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
  //    true, callback will only execute every `delay` milliseconds while the
  //    throttled-function is being called. If no_trailing is false or
  //    unspecified, callback will be executed one final time after the last
  //    throttled-function call. (After the throttled-function has not been
  //    called for `delay` milliseconds, the internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the throttled-function is executed.
  // 
  // Returns:
  // 
  //  (Function) A new, throttled, function.
  
  $.throttle = jq_throttle = function( delay, no_trailing, callback, debounce_mode ) {
    // After wrapper has stopped being called, this timeout ensures that
    // `callback` is executed at the proper times in `throttle` and `end`
    // debounce modes.
    var timeout_id,
      
      // Keep track of the last time `callback` was executed.
      last_exec = 0;
    
    // `no_trailing` defaults to falsy.
    if ( typeof no_trailing !== 'boolean' ) {
      debounce_mode = callback;
      callback = no_trailing;
      no_trailing = undefined;
    }
    
    // The `wrapper` function encapsulates all of the throttling / debouncing
    // functionality and when executed will limit the rate at which `callback`
    // is executed.
    function wrapper() {
      var that = this,
        elapsed = +new Date() - last_exec,
        args = arguments;
      
      // Execute `callback` and update the `last_exec` timestamp.
      function exec() {
        last_exec = +new Date();
        callback.apply( that, args );
      };
      
      // If `debounce_mode` is true (at_begin) this is used to clear the flag
      // to allow future `callback` executions.
      function clear() {
        timeout_id = undefined;
      };
      
      if ( debounce_mode && !timeout_id ) {
        // Since `wrapper` is being called for the first time and
        // `debounce_mode` is true (at_begin), execute `callback`.
        exec();
      }
      
      // Clear any existing timeout.
      timeout_id && clearTimeout( timeout_id );
      
      if ( debounce_mode === undefined && elapsed > delay ) {
        // In throttle mode, if `delay` time has been exceeded, execute
        // `callback`.
        exec();
        
      } else if ( no_trailing !== true ) {
        // In trailing throttle mode, since `delay` time has not been
        // exceeded, schedule `callback` to execute `delay` ms after most
        // recent execution.
        // 
        // If `debounce_mode` is true (at_begin), schedule `clear` to execute
        // after `delay` ms.
        // 
        // If `debounce_mode` is false (at end), schedule `callback` to
        // execute after `delay` ms.
        timeout_id = setTimeout( debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay );
      }
    };
    
    // Set the guid of `wrapper` function to the same of original callback, so
    // it can be removed in jQuery 1.4+ .unbind or .die by using the original
    // callback as a reference.
    if ( $.guid ) {
      wrapper.guid = callback.guid = callback.guid || $.guid++;
    }
    
    // Return the wrapper function.
    return wrapper;
  };
  
  // Method: jQuery.debounce
  // 
  // Debounce execution of a function. Debouncing, unlike throttling,
  // guarantees that a function is only executed a single time, either at the
  // very beginning of a series of calls, or at the very end. If you want to
  // simply rate-limit execution of a function, see the <jQuery.throttle>
  // method.
  // 
  // In this visualization, | is a debounced-function call and X is the actual
  // callback execution:
  // 
  // > Debounced with `at_begin` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // >                          X                                 X
  // > 
  // > Debounced with `at_begin` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X                                 X
  // 
  // Usage:
  // 
  // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
  // > 
  // > jQuery('selector').bind( 'someevent', debounced );
  // > jQuery('selector').unbind( 'someevent', debounced );
  // 
  // This also works in jQuery 1.4+:
  // 
  // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  // 
  // Arguments:
  // 
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
  //    unspecified, callback will only be executed `delay` milliseconds after
  //    the last debounced-function call. If at_begin is true, callback will be
  //    executed only at the first debounced-function call. (After the
  //    throttled-function has not been called for `delay` milliseconds, the
  //    internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the debounced-function is executed.
  // 
  // Returns:
  // 
  //  (Function) A new, debounced, function.
  
  $.debounce = function( delay, at_begin, callback ) {
    return callback === undefined
      ? jq_throttle( delay, at_begin, false )
      : jq_throttle( delay, callback, at_begin !== false );
  };
  
})(this);

// fadeOnScroll jQuery plugin
// by Mark Chitty
// Fades elements in or out as you scroll up or down their container (the window by default)
// Uses requestAnimationFrame (with fallback) for GPU enhanced rendering

// Options        : Default : Explanation
// ---------------------------------------
// - parent       : window  : Parent element to monitor for scroll events
// - elemToWatch  : self    : Element (jQuery object or selector string) to monitor for scroll position relative to parent
// - fadeOutStart : 50      : % distance from top of parent at which element starts fading out
// - fadeOutEnd   : 10      : % distance from top of parent at which element is completely faded out
// - dontFade     : false   : Don't do any opacity changing - useful just for hooking the exitedView and enteredView events
//
// Events
// - enteredView.fadeOnScroll - triggered when elemToWatch enters parent viewport
// - exitedView.fadeOnScroll  - triggered when elemToWatch leaves parent viewport
//
// Notes
// - elements are faded proportionally across the fade out zone
// - fadeOutStart > fadeOutEnd : elem visible at bottom of parent, hidden at top = starts visible, fades out on scroll down
// - fadeOutEnd > fadeOutStart : elem visible at top of parent, hidden at bottom = starts hidden, fades in on scroll down
// - Default behaviour: fading elements are visible when they appear at the bottom of the parent element, start
//   fading when they are half-way up the parent element, and disappear completely when they are 10% from the top.
//
//   ┌ Parent ------------------------┐ 0%
//   |             hidden             |
//   |--------------------------------| 10% - fadeOutEnd
//   |        - fade out zone -       |
//   |       elements are faded       |
//   |       proportionally here      |
//   |--------------------------------| 50% - fadeOutStart
//   |                                |
//   |             visible            |
//   |                                |
//   └--------------------------------┘ 100%

// Usage
// require(['jquery', 'jquery.fadeOnScroll'], function($) {
//     $('.js-fadeOnScroll').fadeOnScroll({
//         parent       : window,
//         fadeOutStart : 50,
//         fadeOutEnd   : 10
//     });
// });

// TODO:
// - Set initial opacity on page load based on element position
// - Plugin removal/clean up methods - unhooking event listeners, etc

// http://www.smashingmagazine.com/2011/10/11/essential-jquery-plugin-patterns/
// http://simonsmith.io/writing-amd-compatible-plugins-for-jquery/

// UMD dance - https://github.com/umdjs/umd
!function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    }
    else {
        factory(root.jQuery);
    }
}(this, function ($) {
    'use strict';

    // Default options
    var defaults = {
        parent        : window,
        elemToWatch   : "",
        fadeOutStart  : 50,
        fadeOutEnd    : 10,
        dontFade      : false    // set to true when you just want to use event triggers
    };

    // Polyfill for requestAnimationFrame and cancelAnimationFrame.
    // https://github.com/darius/requestAnimationFrame
    if (!Date.now) Date.now = function() { return new Date().getTime(); };
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window['webkitRequestAnimationFrame'];
        window.cancelAnimationFrame  = window['webkitCancelAnimationFrame']
                                    || window['webkitCancelRequestAnimationFrame'];
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy
    || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
        var lastTime = 0;
        window.requestAnimationFrame = function(callback) {
            var now      = Date.now();
            var nextTime = Math.max(lastTime + 16, now);
            return setTimeout(function() { callback(lastTime = nextTime); }, nextTime - now);
        };
        window.cancelAnimationFrame = clearTimeout;
    }

    // Constructor
    var FadeOnScroll = function($element, options) {

        // Set up the parent element as a FadeOnScrollParent object
        var $parent   = $(options.parent);
        var fosParent = $parent.data('fadeOnScrollParent');
        if (fosParent === undefined) {
            $parent.data('fadeOnScrollParent', fosParent = new FadeOnScrollParent($parent));
        }
        fosParent.addChild(this);

        // Set the elemToWatch - default to self if user defined option doesn't match anything
        var $elemToWatch = $(options.elemToWatch).length > 0 ? $(options.elemToWatch).first() : $element;

        this.element     = $element;
        this.parent      = $parent;
        this.elemToWatch = $elemToWatch;
        this.options     = options;

        // Returns true (and sets inView property) when any part of elemToWatch is within the (vertical) bounds of parent
        this.isInView = function() {
            var elemDims   = $elemToWatch[0].getBoundingClientRect();
            var parentDims = options.parent == window
                           ? { top: 0, bottom: $parent.height() }
                           : $parent[0].getBoundingClientRect();
            this.inView = (elemDims.bottom > parentDims.top && elemDims.top < parentDims.bottom);
            return this.inView;
        };

        this.setFadeLimits = function() {
            this.parentHeight = $parent.outerHeight();
            this.parentTop    = options.parent == window ? 0 : $parent.offset().top;
            this.fadeOutStart = this.parentHeight * parseInt(options.fadeOutStart)/100;
            this.fadeOutEnd   = this.parentHeight * parseInt(options.fadeOutEnd)/100;
        }

        this.isInView();
        this.setFadeLimits();

        // Update the fade points if the window resizes (debounced)
        var resizeTimeout;
        $parent.on('resize.fadeOnScroll', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(this.setFadeLimits, 100);
        });

    };

    // Parent constructor
    // Animation best practice - http://www.html5rocks.com/en/tutorials/speed/animations/
    var FadeOnScrollParent = function($element) {

        var $parent = $element, fadingChildren = [], parentScrollY = 0, drawing = false;
        this.addChild = function(fos) { fadingChildren.push(fos); };

        // Register the onscroll event handler
        // Very lightweight - only stores the scroll position and then calls the animation manager
        $parent.on('scroll.fadeOnScroll', function(e) {
            parentScrollY = $parent.scrollTop();
            requestAnimationTick();
        });

        // Animation manager
        // requestAnimationFrame calls the animating method fadeElems() max once every 16ms (~=60fps)
        // 'drawing' check means next animation is only called when current one has finished
        var requestAnimationTick = function() {
            if (!drawing) window.requestAnimationFrame(fadeElems);
            drawing = true;
        };
     
        // The actual animation function - controls element opacity based on parent scroll position
        var fadeElems = function() {
            for (var i = 0, l = fadingChildren.length; i < l; i++) {
                var fos = fadingChildren[i], $elem = fos.element;
                var wasInView = fos.inView, checkIsInViewNow = fos.isInView();

                // Trigger events when $elem enters or leaves the $parent viewport
                if ( wasInView && !checkIsInViewNow) $elem.trigger('exitedView.fadeOnScroll');
                if (!wasInView &&  checkIsInViewNow) $elem.trigger('enteredView.fadeOnScroll');

                // Do nothing if $elem is not in $parent viewport or it's set to not fade
                if (fos.options.dontFade || (!wasInView && !checkIsInViewNow)) continue;

                // Set opacity value based on vertical offset of elemToWatch
                var posRelToParent = fos.elemToWatch.offset().top - fos.parentTop;
                var opacity        = (posRelToParent - (parentScrollY + fos.fadeOutEnd)) / (fos.fadeOutStart - fos.fadeOutEnd);
                var opacityBounded = Math.min(Math.max(opacity, 0), 1);
                $elem.css({ 'opacity' : opacityBounded, 'visibility' : (opacityBounded ? 'visible' : 'hidden') });
            }
            drawing = false;    // Set drawing to false so next animation call will run
        };
        
    };

    // Plugin methods and shared properties
    // Plugin.prototype = {
    //     someMethod: function() { }
    // }
 
    // Register the plugin with jQuery
    $.fn.fadeOnScroll = function(options) {
        options = $.extend(true, {}, defaults, options);

        // Ceate a new FadeOnScroll instance for each matched jQuery element
        return this.each(function() {
            var $this = $(this);
            $this.data('fadeOnScroll', new FadeOnScroll($this, options));
        });
    };

    // Like most jQuery plugins, this extends the jQuery global object
    // so there's nothing to return to AMD-module-land

});

/*!
 * jQuery.scrollTo
 * Copyright (c) 2007 Ariel Flesler - aflesler ○ gmail • com | https://github.com/flesler
 * Licensed under MIT
 * https://github.com/flesler/jquery.scrollTo
 * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery
 * @author Ariel Flesler
 * @version 2.1.2
 */
;(function(factory) {
	'use strict';
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof module !== 'undefined' && module.exports) {
		// CommonJS
		module.exports = factory(require('jquery'));
	} else {
		// Global
		factory(jQuery);
	}
})(function($) {
	'use strict';

	var $scrollTo = $.scrollTo = function(target, duration, settings) {
		return $(window).scrollTo(target, duration, settings);
	};

	$scrollTo.defaults = {
		axis:'xy',
		duration: 0,
		limit:true
	};

	function isWin(elem) {
		return !elem.nodeName ||
			$.inArray(elem.nodeName.toLowerCase(), ['iframe','#document','html','body']) !== -1;
	}

	$.fn.scrollTo = function(target, duration, settings) {
		if (typeof duration === 'object') {
			settings = duration;
			duration = 0;
		}
		if (typeof settings === 'function') {
			settings = { onAfter:settings };
		}
		if (target === 'max') {
			target = 9e9;
		}

		settings = $.extend({}, $scrollTo.defaults, settings);
		// Speed is still recognized for backwards compatibility
		duration = duration || settings.duration;
		// Make sure the settings are given right
		var queue = settings.queue && settings.axis.length > 1;
		if (queue) {
			// Let's keep the overall duration
			duration /= 2;
		}
		settings.offset = both(settings.offset);
		settings.over = both(settings.over);

		return this.each(function() {
			// Null target yields nothing, just like jQuery does
			if (target === null) return;

			var win = isWin(this),
				elem = win ? this.contentWindow || window : this,
				$elem = $(elem),
				targ = target,
				attr = {},
				toff;

			switch (typeof targ) {
				// A number will pass the regex
				case 'number':
				case 'string':
					if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
						targ = both(targ);
						// We are done
						break;
					}
					// Relative/Absolute selector
					targ = win ? $(targ) : $(targ, elem);
					/* falls through */
				case 'object':
					if (targ.length === 0) return;
					// DOMElement / jQuery
					if (targ.is || targ.style) {
						// Get the real position of the target
						toff = (targ = $(targ)).offset();
					}
			}

			var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;

			$.each(settings.axis.split(''), function(i, axis) {
				var Pos	= axis === 'x' ? 'Left' : 'Top',
					pos = Pos.toLowerCase(),
					key = 'scroll' + Pos,
					prev = $elem[key](),
					max = $scrollTo.max(elem, axis);

				if (toff) {// jQuery / DOMElement
					attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);

					// If it's a dom element, reduce the margin
					if (settings.margin) {
						attr[key] -= parseInt(targ.css('margin'+Pos), 10) || 0;
						attr[key] -= parseInt(targ.css('border'+Pos+'Width'), 10) || 0;
					}

					attr[key] += offset[pos] || 0;

					if (settings.over[pos]) {
						// Scroll to a fraction of its width/height
						attr[key] += targ[axis === 'x'?'width':'height']() * settings.over[pos];
					}
				} else {
					var val = targ[pos];
					// Handle percentage values
					attr[key] = val.slice && val.slice(-1) === '%' ?
						parseFloat(val) / 100 * max
						: val;
				}

				// Number or 'number'
				if (settings.limit && /^\d+$/.test(attr[key])) {
					// Check the limits
					attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
				}

				// Don't waste time animating, if there's no need.
				if (!i && settings.axis.length > 1) {
					if (prev === attr[key]) {
						// No animation needed
						attr = {};
					} else if (queue) {
						// Intermediate animation
						animate(settings.onAfterFirst);
						// Don't animate this axis again in the next iteration.
						attr = {};
					}
				}
			});

			animate(settings.onAfter);

			function animate(callback) {
				var opts = $.extend({}, settings, {
					// The queue setting conflicts with animate()
					// Force it to always be true
					queue: true,
					duration: duration,
					complete: callback && function() {
						callback.call(elem, targ, settings);
					}
				});
				$elem.animate(attr, opts);
			}
		});
	};

	// Max scrolling position, works on quirks mode
	// It only fails (not too badly) on IE, quirks mode.
	$scrollTo.max = function(elem, axis) {
		var Dim = axis === 'x' ? 'Width' : 'Height',
			scroll = 'scroll'+Dim;

		if (!isWin(elem))
			return elem[scroll] - $(elem)[Dim.toLowerCase()]();

		var size = 'client' + Dim,
			doc = elem.ownerDocument || elem.document,
			html = doc.documentElement,
			body = doc.body;

		return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);
	};

	function both(val) {
		return $.isFunction(val) || $.isPlainObject(val) ? val : { top:val, left:val };
	}

	// Add special hooks so that window scroll properties can be animated
	$.Tween.propHooks.scrollLeft =
	$.Tween.propHooks.scrollTop = {
		get: function(t) {
			return $(t.elem)[t.prop]();
		},
		set: function(t) {
			var curr = this.get(t);
			// If interrupt is true and user scrolled, stop animating
			if (t.options.interrupt && t._last && t._last !== curr) {
				return $(t.elem).stop();
			}
			var next = Math.round(t.now);
			// Don't waste CPU
			// Browsers don't render floating point scroll
			if (curr !== next) {
				$(t.elem)[t.prop](next);
				t._last = this.get(t);
			}
		}
	};

	// AMD requirement
	return $scrollTo;
});

// Extended carousel with All New Progress-o-meters (TM)

// Umunandi global
var Umunandi = Umunandi || {};

(function (Umunandi) {

  // Carousel Progressometer Class
  // Supporting API for svg.progressometer
  var CarouselProgress = function($carousel) {

    // When jQuery calls() the class methods below it passes in a reference to the current 
    // element as 'this'. We want the methods to reference the CarouselProgress class, not
    // the passed-in element, so we create our own '_this' reference that can't be overriden.
    var _this = this;

    _this.$carousel = $carousel;
    _this.carouselData = $carousel.data('bs.carousel');
    _this.T_STATIC = _this.carouselData.options.interval - $carousel.carousel.Constructor.TRANSITION_DURATION;
    _this.isPaused = false;
    _this.pausedProgress = 0;

    CarouselProgress.prototype.getActiveEl = function(e) {
      var $activeSlide = e ? $(e.relatedTarget) : _this.$carousel.find('.item.active');
      return $activeSlide.find('.radial-progress');
    }

    CarouselProgress.prototype.setCss = function(progress, speed) {
      // svg.progressometer strokeDashoffset range: min = 1000, max = 1315
      _this.$activeEl.css({
        strokeDashoffset: parseInt(1000 + (progress * 315)),
        transitionDuration: speed.toFixed(0) + 'ms'
      });
    }
    
    CarouselProgress.prototype.resetProgress = function(e) {
      _this.pausedProgress = 0;
      _this.$activeEl = _this.getActiveEl(e);
      _this.setCss(0, 0);
    }
    
    CarouselProgress.prototype.startProgress = function(startFrom) {
      startFrom = startFrom > 1 ? 1 : startFrom < 0 ? 0 : parseFloat(startFrom) || 0;
      var timeRemaining = _this.T_STATIC * (1 - startFrom);
      _this.isPaused = false;
      _this.t0 = Date.now() - (_this.T_STATIC * startFrom);
      _this.setCss(startFrom, timeRemaining);
      setTimeout(_this.setCss, 0, 1, timeRemaining);
    }

    CarouselProgress.prototype.startCarousel = function() {
      _this.$activeEl = _this.getActiveEl();
      _this.startProgress(_this.pausedProgress);
      _this.timeout = clearTimeout(_this.timeout);
      _this.timeout = setTimeout(function() {
        _this.$carousel.carousel('next');
        _this.$carousel.carousel('cycle');
      }, _this.T_STATIC * (1 - _this.pausedProgress));
    }
    
    CarouselProgress.prototype.pauseCarousel = function() {
      var pausedProgress = (Date.now() - _this.t0) / _this.T_STATIC;
      _this.pausedProgress = pausedProgress > 1 ? 1 : pausedProgress < 0 ? 0 : pausedProgress || 0;
      _this.isPaused = true;
      _this.carouselData.interval = clearInterval(_this.carouselData.interval);
      _this.timeout = clearTimeout(_this.timeout);
      _this.setCss(_this.pausedProgress, 0);
    }
    
    CarouselProgress.prototype.onHover = function () {
      _this.isPaused ? _this.startCarousel() : _this.pauseCarousel();
    }
    
    CarouselProgress.prototype.onSlid = function () {
      if (_this.carouselData.interval) _this.startProgress(); 
    }
  }

  // export
  Umunandi.CarouselProgress = CarouselProgress;

})(Umunandi);

// Common scripts that run on all pages

// Umunandi global
var Umunandi = Umunandi || {};

(function (Umunandi) {

  function init() {
    // Globally limit javascript click actions
    $('a[href="#"]').click(function(e) { e.preventDefault(); });  

    // Reset the screen to (0,0)
    $.scrollTo(0);
    
    // Track navbar position to control floating/fixed state
    var $navBar = $('.js-main-nav');
    var $navBarRef = $('.js-main-nav-position-ref');
    var navBarRefTop;

    function getNavBarRefTop() { navBarRefTop = $navBarRef.offset().top; }
    getNavBarRefTop();

    $(window).on('resize orientationchange', $.debounce(100, getNavBarRefTop));
    $(document).scroll(function() {
      $navBar.toggleClass('fixed', $(this).scrollTop() > navBarRefTop); }
    );

    // TODO : IE image cover fit polyfill
    // https://medium.com/@primozcigler/neat-trick-for-css-object-fit-fallback-on-edge-and-other-browsers-afbc53bbb2c3
  }

  // export
  Umunandi.common = init;

})(Umunandi);

// Home page scripts

// Umunandi global
var Umunandi = Umunandi || {};

(function (Umunandi) {

  function homePage() {

    // ScrollTo behaviour
    $('[data-scrollto]').off().on('click', function(e) {
      e.preventDefault();
      $('.nav-toggle-checkbox').prop('checked', false); // Close the mobile menu
      var $this = $(this);
      var scrollOpts = {
        duration: $this.data().scrollto,
        offset: $this.data().scrolloffset
      };
      $.scrollTo($this.attr('href'), scrollOpts);
    });

    // Carousel
    var carouselSlideInterval = 12000;
    var carouselOptions = { interval: carouselSlideInterval, pause: '' };
    var $carousel = $('.js-kids-carousel').carousel(carouselOptions).carousel('pause');
    var carouselProgress = new Umunandi.CarouselProgress($carousel);

    $('.js-kids-carousel')
      .on('slide.bs.carousel', carouselProgress.resetProgress)
      .on('slid.bs.carousel',  carouselProgress.onSlid)
      .hover(carouselProgress.onHover)
      .fadeOnScroll({ dontFade : true })
      .on('enteredView.fadeOnScroll', carouselProgress.startCarousel)
      .on('exitedView.fadeOnScroll',  carouselProgress.pauseCarousel)
    ;

    // Normalise carousel slide heights
    $(window).on('resize orientationchange', function () {
      var items = $('.js-kids-carousel .item'), maxH = 0;
      items.css('min-height', '');
      items.each(function() { if ($(this).height() > maxH) maxH = $(this).height(); });
      items.each(function() { $(this).css('min-height', maxH + 'px'); });
    }).resize();

  }

  // export
  Umunandi.home = homePage;

})(Umunandi);

/* ========================================================================
 * DOM-based Routing
 * Based on http://goo.gl/EUTi53 by Paul Irish
 *
 * Only fires on body classes that match. If a body class contains a dash,
 * replace the dash with an underscore when adding it to the object below.
 *
 * Google CDN, Latest jQuery
 * ======================================================================== */

// Set up Umunandi global to hang everything else off
var Umunandi = Umunandi || {};

(function($) {

  var SCRIPT_UTIL = {
    namespace : Umunandi,

    loadEvents : function() {
      SCRIPT_UTIL.fire('common');
      $.each(document.body.className.replace(/-/g, '_').split(/\s+/), function(i, classnm) {
        SCRIPT_UTIL.fire(classnm);
      });
    },

    fire : function(funcname, args) {
      if (typeof SCRIPT_UTIL.namespace[funcname] === 'function')
        SCRIPT_UTIL.namespace[funcname](args);
    }
  }

  $(document).ready(SCRIPT_UTIL.loadEvents);

})(jQuery);

// Umunandi global
var Umunandi = Umunandi || {};

(function (Umunandi) {

  function onClick(e) {
    e.preventDefault();
    $('.price-box').removeClass('active');
    $(this).addClass('active');
  }

  function sponsorPage() {
    $('.price-box').off().on('click', onClick);
  }

  // export
  Umunandi.sponsor = sponsorPage;

})(Umunandi);
