/* ========================================================================
 * umunandi.org main.js - Entry point script and module manager.
 *
 * A global 'umunandi' object provides a namespace for all other script
 * modules hang off. Modules are defined using the method
 * umunandi.define(pagename, [priority], func). This adds them to the
 * umunandi namespace and associates them with the name of a specific page.
 * 
 * When a page loads, load() calls all modules that are registered
 * with a module name that matches any class in the <body> tag (dashes in
 * class names are replaced by underscores). Based on http://goo.gl/EUTi53.
 * 
 * Modules are loaded in order of ascending priority. Default priority = 10.
 * e.g. a module with priority 2 is loaded before a module of priority 1000.
 * 
 * Grunt is responsible for concat'ing all the scripts in /src.
 * 
 * Example
 * -------
 * - In home.js
 *   umunandi.define('home', function() { useful js stuff });
 * 
 * - In anims.js
 *   umunandi.define('home', 5, function() { cool animations });
 * 
 * - In home.php
 *   <body class="page blue home"> ... </body>
 * 
 * When home.php loads, the script will run any functions with a module id
 * of 'page', 'blue' or 'home'. This means the 'home' modules defined in 
 * home.js and anims.js will both be loaded - anims.js will load first.
 * ======================================================================== */

var Umunandi = function() {
  this.globals = {};
  this.pageScripts = {};
};

Umunandi.prototype.define = function(moduleId, priority, func) {
  func = typeof priority === 'function' ? priority : func;
  priority = isNaN(priority) ? 10 : priority;
  this.pageScripts[moduleId] = this.pageScripts[moduleId] || [];
  this.pageScripts[moduleId].push({ priority: priority, func: func });
  this.pageScripts[moduleId].sort(function(a, b) { return a.priority - b.priority; });
}

Umunandi.prototype.load = function() {
  this.run('common');
  var pageClasses = document.body.className.replace(/-/g, '_').split(/\s+/);
  pageClasses.forEach(function(className) {
    this.run(className);
  }.bind(this));
}

Umunandi.prototype.run = function(moduleId) {
  if (!Array.isArray(this.pageScripts[moduleId])) return;
  // console.log('Running modules', moduleId, this.pageScripts[moduleId]);
  this.pageScripts[moduleId].forEach(function(module) { module.func(); });
};

var umunandi = new Umunandi();

(function($) { $(document).ready(umunandi.load.bind(umunandi)); })(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.7
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.7'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.7
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.7'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.7
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.7'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element.addClass('in')

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (document !== e.target &&
            this.$element[0] !== e.target &&
            !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
// 
// Topic: Note for non-jQuery users
// 
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
// 
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().

(function(window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Since jQuery really isn't required for this plugin, use `jQuery` as the
  // namespace only if it already exists, otherwise use the `Cowboy` namespace,
  // creating it if necessary.
  var $ = window.jQuery || window.Cowboy || ( window.Cowboy = {} ),
    
    // Internal method reference.
    jq_throttle;
  
  // Method: jQuery.throttle
  // 
  // Throttle execution of a function. Especially useful for rate limiting
  // execution of handlers on events like resize and scroll. If you want to
  // rate-limit execution of a function to a single time, see the
  // <jQuery.debounce> method.
  // 
  // In this visualization, | is a throttled-function call and X is the actual
  // callback execution:
  // 
  // > Throttled with `no_trailing` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X    X        X    X    X    X    X    X
  // > 
  // > Throttled with `no_trailing` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X             X    X    X    X    X
  // 
  // Usage:
  // 
  // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
  // > 
  // > jQuery('selector').bind( 'someevent', throttled );
  // > jQuery('selector').unbind( 'someevent', throttled );
  // 
  // This also works in jQuery 1.4+:
  // 
  // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  // 
  // Arguments:
  // 
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
  //    true, callback will only execute every `delay` milliseconds while the
  //    throttled-function is being called. If no_trailing is false or
  //    unspecified, callback will be executed one final time after the last
  //    throttled-function call. (After the throttled-function has not been
  //    called for `delay` milliseconds, the internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the throttled-function is executed.
  // 
  // Returns:
  // 
  //  (Function) A new, throttled, function.
  
  $.throttle = jq_throttle = function( delay, no_trailing, callback, debounce_mode ) {
    // After wrapper has stopped being called, this timeout ensures that
    // `callback` is executed at the proper times in `throttle` and `end`
    // debounce modes.
    var timeout_id,
      
      // Keep track of the last time `callback` was executed.
      last_exec = 0;
    
    // `no_trailing` defaults to falsy.
    if ( typeof no_trailing !== 'boolean' ) {
      debounce_mode = callback;
      callback = no_trailing;
      no_trailing = undefined;
    }
    
    // The `wrapper` function encapsulates all of the throttling / debouncing
    // functionality and when executed will limit the rate at which `callback`
    // is executed.
    function wrapper() {
      var that = this,
        elapsed = +new Date() - last_exec,
        args = arguments;
      
      // Execute `callback` and update the `last_exec` timestamp.
      function exec() {
        last_exec = +new Date();
        callback.apply( that, args );
      };
      
      // If `debounce_mode` is true (at_begin) this is used to clear the flag
      // to allow future `callback` executions.
      function clear() {
        timeout_id = undefined;
      };
      
      if ( debounce_mode && !timeout_id ) {
        // Since `wrapper` is being called for the first time and
        // `debounce_mode` is true (at_begin), execute `callback`.
        exec();
      }
      
      // Clear any existing timeout.
      timeout_id && clearTimeout( timeout_id );
      
      if ( debounce_mode === undefined && elapsed > delay ) {
        // In throttle mode, if `delay` time has been exceeded, execute
        // `callback`.
        exec();
        
      } else if ( no_trailing !== true ) {
        // In trailing throttle mode, since `delay` time has not been
        // exceeded, schedule `callback` to execute `delay` ms after most
        // recent execution.
        // 
        // If `debounce_mode` is true (at_begin), schedule `clear` to execute
        // after `delay` ms.
        // 
        // If `debounce_mode` is false (at end), schedule `callback` to
        // execute after `delay` ms.
        timeout_id = setTimeout( debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay );
      }
    };
    
    // Set the guid of `wrapper` function to the same of original callback, so
    // it can be removed in jQuery 1.4+ .unbind or .die by using the original
    // callback as a reference.
    if ( $.guid ) {
      wrapper.guid = callback.guid = callback.guid || $.guid++;
    }
    
    // Return the wrapper function.
    return wrapper;
  };
  
  // Method: jQuery.debounce
  // 
  // Debounce execution of a function. Debouncing, unlike throttling,
  // guarantees that a function is only executed a single time, either at the
  // very beginning of a series of calls, or at the very end. If you want to
  // simply rate-limit execution of a function, see the <jQuery.throttle>
  // method.
  // 
  // In this visualization, | is a debounced-function call and X is the actual
  // callback execution:
  // 
  // > Debounced with `at_begin` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // >                          X                                 X
  // > 
  // > Debounced with `at_begin` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X                                 X
  // 
  // Usage:
  // 
  // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
  // > 
  // > jQuery('selector').bind( 'someevent', debounced );
  // > jQuery('selector').unbind( 'someevent', debounced );
  // 
  // This also works in jQuery 1.4+:
  // 
  // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  // 
  // Arguments:
  // 
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
  //    unspecified, callback will only be executed `delay` milliseconds after
  //    the last debounced-function call. If at_begin is true, callback will be
  //    executed only at the first debounced-function call. (After the
  //    throttled-function has not been called for `delay` milliseconds, the
  //    internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the debounced-function is executed.
  // 
  // Returns:
  // 
  //  (Function) A new, debounced, function.
  
  $.debounce = function( delay, at_begin, callback ) {
    return callback === undefined
      ? jq_throttle( delay, at_begin, false )
      : jq_throttle( delay, callback, at_begin !== false );
  };
  
})(this);

// fadeOnScroll jQuery plugin
// by Mark Chitty
// Fades elements in or out as you scroll up or down their container (the window by default)
// Uses requestAnimationFrame (with fallback) for GPU enhanced rendering

// Options        : Default : Explanation
// ---------------------------------------
// - parent       : window  : Parent element to monitor for scroll events
// - elemToWatch  : self    : Element (jQuery object or selector string) to monitor for scroll position relative to parent
// - fadeOutStart : 50      : % distance from top of parent at which element starts fading out
// - fadeOutEnd   : 10      : % distance from top of parent at which element is completely faded out
// - dontFade     : false   : Don't do any opacity changing - useful just for hooking the exitedView and enteredView events
//
// Events
// - enteredView.fadeOnScroll - triggered when elemToWatch enters parent viewport
// - exitedView.fadeOnScroll  - triggered when elemToWatch leaves parent viewport
//
// Notes
// - elements are faded proportionally across the fade out zone
// - fadeOutStart > fadeOutEnd : elem visible at bottom of parent, hidden at top = starts visible, fades out on scroll down
// - fadeOutEnd > fadeOutStart : elem visible at top of parent, hidden at bottom = starts hidden, fades in on scroll down
// - Default behaviour: fading elements are visible when they appear at the bottom of the parent element, start
//   fading when they are half-way up the parent element, and disappear completely when they are 10% from the top.
//
//   ┌ Parent ------------------------┐ 0%
//   |             hidden             |
//   |--------------------------------| 10% - fadeOutEnd
//   |        - fade out zone -       |
//   |       elements are faded       |
//   |       proportionally here      |
//   |--------------------------------| 50% - fadeOutStart
//   |                                |
//   |             visible            |
//   |                                |
//   └--------------------------------┘ 100%

// Usage
// require(['jquery', 'jquery.fadeOnScroll'], function($) {
//     $('.js-fadeOnScroll').fadeOnScroll({
//         parent       : window,
//         fadeOutStart : 50,
//         fadeOutEnd   : 10
//     });
// });

// TODO:
// - Set initial opacity on page load based on element position
// - Plugin removal/clean up methods - unhooking event listeners, etc

// http://www.smashingmagazine.com/2011/10/11/essential-jquery-plugin-patterns/
// http://simonsmith.io/writing-amd-compatible-plugins-for-jquery/

// UMD dance - https://github.com/umdjs/umd
!function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    }
    else {
        factory(root.jQuery);
    }
}(this, function ($) {
    'use strict';

    // Default options
    var defaults = {
        parent        : window,
        elemToWatch   : "",
        fadeOutStart  : 50,
        fadeOutEnd    : 10,
        dontFade      : false    // set to true when you just want to use event triggers
    };

    // Polyfill for requestAnimationFrame and cancelAnimationFrame.
    // https://github.com/darius/requestAnimationFrame
    if (!Date.now) Date.now = function() { return new Date().getTime(); };
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window['webkitRequestAnimationFrame'];
        window.cancelAnimationFrame  = window['webkitCancelAnimationFrame']
                                    || window['webkitCancelRequestAnimationFrame'];
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy
    || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
        var lastTime = 0;
        window.requestAnimationFrame = function(callback) {
            var now      = Date.now();
            var nextTime = Math.max(lastTime + 16, now);
            return setTimeout(function() { callback(lastTime = nextTime); }, nextTime - now);
        };
        window.cancelAnimationFrame = clearTimeout;
    }

    // Constructor
    var FadeOnScroll = function($element, options) {

        // Set up the parent element as a FadeOnScrollParent object
        var $parent   = $(options.parent);
        var fosParent = $parent.data('fadeOnScrollParent');
        if (fosParent === undefined) {
            $parent.data('fadeOnScrollParent', fosParent = new FadeOnScrollParent($parent));
        }
        fosParent.addChild(this);

        // Set the elemToWatch - default to self if user defined option doesn't match anything
        var $elemToWatch = $(options.elemToWatch).length > 0 ? $(options.elemToWatch).first() : $element;

        this.element     = $element;
        this.parent      = $parent;
        this.elemToWatch = $elemToWatch;
        this.options     = options;

        // Returns true (and sets inView property) when any part of elemToWatch is within the (vertical) bounds of parent
        this.isInView = function() {
            var elemDims   = $elemToWatch[0].getBoundingClientRect();
            var parentDims = options.parent == window
                           ? { top: 0, bottom: $parent.height() }
                           : $parent[0].getBoundingClientRect();
            this.inView = (elemDims.bottom > parentDims.top && elemDims.top < parentDims.bottom);
            return this.inView;
        };

        this.setFadeLimits = function() {
            this.parentHeight = $parent.outerHeight();
            this.parentTop    = options.parent == window ? 0 : $parent.offset().top;
            this.fadeOutStart = this.parentHeight * parseInt(options.fadeOutStart)/100;
            this.fadeOutEnd   = this.parentHeight * parseInt(options.fadeOutEnd)/100;
        }

        this.isInView();
        this.setFadeLimits();

        // Update the fade points if the window resizes (debounced)
        var resizeTimeout;
        $parent.on('resize.fadeOnScroll', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(this.setFadeLimits, 100);
        });

    };

    // Parent constructor
    // Animation best practice - http://www.html5rocks.com/en/tutorials/speed/animations/
    var FadeOnScrollParent = function($element) {

        var $parent = $element, fadingChildren = [], parentScrollY = 0, drawing = false;
        this.addChild = function(fos) { fadingChildren.push(fos); };

        // Register the onscroll event handler
        // Very lightweight - only stores the scroll position and then calls the animation manager
        $parent.on('scroll.fadeOnScroll', function(e) {
            parentScrollY = $parent.scrollTop();
            requestAnimationTick();
        });

        // Animation manager
        // requestAnimationFrame calls the animating method fadeElems() max once every 16ms (~=60fps)
        // 'drawing' check means next animation is only called when current one has finished
        var requestAnimationTick = function() {
            if (!drawing) window.requestAnimationFrame(fadeElems);
            drawing = true;
        };
     
        // The actual animation function - controls element opacity based on parent scroll position
        var fadeElems = function() {
            for (var i = 0, l = fadingChildren.length; i < l; i++) {
                var fos = fadingChildren[i], $elem = fos.element;
                var wasInView = fos.inView, checkIsInViewNow = fos.isInView();

                // Trigger events when $elem enters or leaves the $parent viewport
                if ( wasInView && !checkIsInViewNow) $elem.trigger('exitedView.fadeOnScroll');
                if (!wasInView &&  checkIsInViewNow) $elem.trigger('enteredView.fadeOnScroll');

                // Do nothing if $elem is not in $parent viewport or it's set to not fade
                if (fos.options.dontFade || (!wasInView && !checkIsInViewNow)) continue;

                // Set opacity value based on vertical offset of elemToWatch
                var posRelToParent = fos.elemToWatch.offset().top - fos.parentTop;
                var opacity        = (posRelToParent - (parentScrollY + fos.fadeOutEnd)) / (fos.fadeOutStart - fos.fadeOutEnd);
                var opacityBounded = Math.min(Math.max(opacity, 0), 1);
                $elem.css({ 'opacity' : opacityBounded, 'visibility' : (opacityBounded ? 'visible' : 'hidden') });
            }
            drawing = false;    // Set drawing to false so next animation call will run
        };
        
    };

    // Plugin methods and shared properties
    // Plugin.prototype = {
    //     someMethod: function() { }
    // }
 
    // Register the plugin with jQuery
    $.fn.fadeOnScroll = function(options) {
        options = $.extend(true, {}, defaults, options);

        // Ceate a new FadeOnScroll instance for each matched jQuery element
        return this.each(function() {
            var $this = $(this);
            $this.data('fadeOnScroll', new FadeOnScroll($this, options));
        });
    };

    // Like most jQuery plugins, this extends the jQuery global object
    // so there's nothing to return to AMD-module-land

});

/*!
 * jQuery.scrollTo
 * Copyright (c) 2007 Ariel Flesler - aflesler ○ gmail • com | https://github.com/flesler
 * Licensed under MIT
 * https://github.com/flesler/jquery.scrollTo
 * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery
 * @author Ariel Flesler
 * @version 2.1.2
 */
;(function(factory) {
	'use strict';
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof module !== 'undefined' && module.exports) {
		// CommonJS
		module.exports = factory(require('jquery'));
	} else {
		// Global
		factory(jQuery);
	}
})(function($) {
	'use strict';

	var $scrollTo = $.scrollTo = function(target, duration, settings) {
		return $(window).scrollTo(target, duration, settings);
	};

	$scrollTo.defaults = {
		axis:'xy',
		duration: 0,
		limit:true
	};

	function isWin(elem) {
		return !elem.nodeName ||
			$.inArray(elem.nodeName.toLowerCase(), ['iframe','#document','html','body']) !== -1;
	}

	$.fn.scrollTo = function(target, duration, settings) {
		if (typeof duration === 'object') {
			settings = duration;
			duration = 0;
		}
		if (typeof settings === 'function') {
			settings = { onAfter:settings };
		}
		if (target === 'max') {
			target = 9e9;
		}

		settings = $.extend({}, $scrollTo.defaults, settings);
		// Speed is still recognized for backwards compatibility
		duration = duration || settings.duration;
		// Make sure the settings are given right
		var queue = settings.queue && settings.axis.length > 1;
		if (queue) {
			// Let's keep the overall duration
			duration /= 2;
		}
		settings.offset = both(settings.offset);
		settings.over = both(settings.over);

		return this.each(function() {
			// Null target yields nothing, just like jQuery does
			if (target === null) return;

			var win = isWin(this),
				elem = win ? this.contentWindow || window : this,
				$elem = $(elem),
				targ = target,
				attr = {},
				toff;

			switch (typeof targ) {
				// A number will pass the regex
				case 'number':
				case 'string':
					if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
						targ = both(targ);
						// We are done
						break;
					}
					// Relative/Absolute selector
					targ = win ? $(targ) : $(targ, elem);
					/* falls through */
				case 'object':
					if (targ.length === 0) return;
					// DOMElement / jQuery
					if (targ.is || targ.style) {
						// Get the real position of the target
						toff = (targ = $(targ)).offset();
					}
			}

			var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;

			$.each(settings.axis.split(''), function(i, axis) {
				var Pos	= axis === 'x' ? 'Left' : 'Top',
					pos = Pos.toLowerCase(),
					key = 'scroll' + Pos,
					prev = $elem[key](),
					max = $scrollTo.max(elem, axis);

				if (toff) {// jQuery / DOMElement
					attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);

					// If it's a dom element, reduce the margin
					if (settings.margin) {
						attr[key] -= parseInt(targ.css('margin'+Pos), 10) || 0;
						attr[key] -= parseInt(targ.css('border'+Pos+'Width'), 10) || 0;
					}

					attr[key] += offset[pos] || 0;

					if (settings.over[pos]) {
						// Scroll to a fraction of its width/height
						attr[key] += targ[axis === 'x'?'width':'height']() * settings.over[pos];
					}
				} else {
					var val = targ[pos];
					// Handle percentage values
					attr[key] = val.slice && val.slice(-1) === '%' ?
						parseFloat(val) / 100 * max
						: val;
				}

				// Number or 'number'
				if (settings.limit && /^\d+$/.test(attr[key])) {
					// Check the limits
					attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
				}

				// Don't waste time animating, if there's no need.
				if (!i && settings.axis.length > 1) {
					if (prev === attr[key]) {
						// No animation needed
						attr = {};
					} else if (queue) {
						// Intermediate animation
						animate(settings.onAfterFirst);
						// Don't animate this axis again in the next iteration.
						attr = {};
					}
				}
			});

			animate(settings.onAfter);

			function animate(callback) {
				var opts = $.extend({}, settings, {
					// The queue setting conflicts with animate()
					// Force it to always be true
					queue: true,
					duration: duration,
					complete: callback && function() {
						callback.call(elem, targ, settings);
					}
				});
				$elem.animate(attr, opts);
			}
		});
	};

	// Max scrolling position, works on quirks mode
	// It only fails (not too badly) on IE, quirks mode.
	$scrollTo.max = function(elem, axis) {
		var Dim = axis === 'x' ? 'Width' : 'Height',
			scroll = 'scroll'+Dim;

		if (!isWin(elem))
			return elem[scroll] - $(elem)[Dim.toLowerCase()]();

		var size = 'client' + Dim,
			doc = elem.ownerDocument || elem.document,
			html = doc.documentElement,
			body = doc.body;

		return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);
	};

	function both(val) {
		return $.isFunction(val) || $.isPlainObject(val) ? val : { top:val, left:val };
	}

	// Add special hooks so that window scroll properties can be animated
	$.Tween.propHooks.scrollLeft =
	$.Tween.propHooks.scrollTop = {
		get: function(t) {
			return $(t.elem)[t.prop]();
		},
		set: function(t) {
			var curr = this.get(t);
			// If interrupt is true and user scrolled, stop animating
			if (t.options.interrupt && t._last && t._last !== curr) {
				return $(t.elem).stop();
			}
			var next = Math.round(t.now);
			// Don't waste CPU
			// Browsers don't render floating point scroll
			if (curr !== next) {
				$(t.elem)[t.prop](next);
				t._last = this.get(t);
			}
		}
	};

	// AMD requirement
	return $scrollTo;
});

// Extended carousel with All New Progress-o-meters (TM)
umunandi.define('home', 5, function () {

  // Carousel Progressometer Class
  // Supporting API for svg.progressometer
  var CarouselProgress = function($carousel) {

    // When jQuery calls() the class methods below it passes in a reference to the current 
    // element as 'this'. We want the methods to reference the CarouselProgress class, not
    // the passed-in element, so we create our own '_this' reference that can't be overriden.
    var _this = this;

    _this.$carousel = $carousel;
    _this.carouselData = $carousel.data('bs.carousel');
    _this.T_STATIC = _this.carouselData.options.interval - $carousel.carousel.Constructor.TRANSITION_DURATION;
    _this.isPaused = false;
    _this.pausedProgress = 0;

    CarouselProgress.prototype.getActiveEl = function(e) {
      var $activeSlide = e ? $(e.relatedTarget) : _this.$carousel.find('.item.active');
      return $activeSlide.find('.radial-progress');
    }

    CarouselProgress.prototype.setCss = function(progress, speed) {
      // svg.progressometer strokeDashoffset range: min = 1000, max = 1315
      _this.$activeEl.css({
        strokeDashoffset: parseInt(1000 + (progress * 315)),
        transitionDuration: speed.toFixed(0) + 'ms'
      });
    }
    
    CarouselProgress.prototype.resetProgress = function(e) {
      _this.pausedProgress = 0;
      _this.$activeEl = _this.getActiveEl(e);
      _this.setCss(0, 0);
    }
    
    CarouselProgress.prototype.startProgress = function(startFrom) {
      startFrom = startFrom > 1 ? 1 : startFrom < 0 ? 0 : parseFloat(startFrom) || 0;
      var timeRemaining = _this.T_STATIC * (1 - startFrom);
      _this.isPaused = false;
      _this.t0 = Date.now() - (_this.T_STATIC * startFrom);
      _this.setCss(startFrom, timeRemaining);
      setTimeout(_this.setCss, 0, 1, timeRemaining);
    }

    CarouselProgress.prototype.startCarousel = function() {
      _this.$activeEl = _this.getActiveEl();
      _this.startProgress(_this.pausedProgress);
      _this.timeout = clearTimeout(_this.timeout);
      _this.timeout = setTimeout(function() {
        _this.$carousel.carousel('next');
        _this.$carousel.carousel('cycle');
      }, _this.T_STATIC * (1 - _this.pausedProgress));
    }
    
    CarouselProgress.prototype.pauseCarousel = function() {
      var pausedProgress = (Date.now() - _this.t0) / _this.T_STATIC;
      _this.pausedProgress = pausedProgress > 1 ? 1 : pausedProgress < 0 ? 0 : pausedProgress || 0;
      _this.isPaused = true;
      _this.carouselData.interval = clearInterval(_this.carouselData.interval);
      _this.timeout = clearTimeout(_this.timeout);
      _this.setCss(_this.pausedProgress, 0);
    }
    
    CarouselProgress.prototype.onHover = function () {
      _this.isPaused ? _this.startCarousel() : _this.pauseCarousel();
    }
    
    CarouselProgress.prototype.onSlid = function () {
      if (_this.carouselData.interval) _this.startProgress(); 
    }
  }

  umunandi.CarouselProgress = CarouselProgress;

});

// Form related scripts

umunandi.define('form', function() {

  var $form = $('.umunandi-form');

  // Autoresize textareas to fit content
  $('textarea').each(function () {
    this.setAttribute('style', 'height:' + (this.scrollHeight) + 'px; overflow-y:hidden;');
  }).on('input', function () {
    this.style.height = 'auto';
    this.style.height = (this.scrollHeight) + 'px';
  });

  // Validation - uses HTML5 Constraint Validation API - https://mzl.la/2QHPDzW
  function validateField(elem) {
    function getErrCode(elem) {
      for (key in elem.validity) if (key != 'valid' && elem.validity[key]) return key;
    }
    var isErr = !elem.checkValidity();
    var msgElemId = elem.name + 'InputMsg';
    $('#' + msgElemId).text(isErr ? elem.dataset[getErrCode(elem)] : '');
    $(elem).attr('aria-describedby', isErr ? msgElemId : null);
    $(elem).closest('.form-group').toggleClass('error', isErr);
  }
  $form.on('blur', ':input', function () { validateField(this); });

  // Submission
  $form.on('submit', function (evt) {
    evt.preventDefault();
    $('.form-error').hide();
    $(':input', this).each(function (i, elem) { validateField(elem); });
    if (!this.checkValidity()) return false;
    var formData = {
      name: this.name,
      action: this.dataset.wpAction,
      nonce: this.dataset.nonce
    };
    $form.serializeArray().map(function (field) { formData[field['name']] = field['value']; });
    $form.find('button').toggleClass('submitted', true).prop('disabled', true);
    var jqXHR = $.post($form.attr('action'), formData);

    // Response
    jqXHR.done(function (response) {
      if (response.success) $form.css('height', $form.height()).empty().html(response.data);
      else showFormError(response.data);
    });

    // Error handling
    jqXHR.fail(function (jqXHR, status, err) {
      var errReason = jqXHR.status + ' - ' + jqXHR.statusText;
      if (jqXHR.statusText === 'timeout') showFormError($form[0].dataset.errorTimeout, errReason);
      else showFormError($form[0].dataset.errorGeneric, errReason);
    });
  });

  function showFormError(msg, reason) {
    $form.find('.form-error').show();
    $form.find('.msg').text(msg);
    $form.find('.reason').text(typeof reason === 'undefined' ? '' : '(' + reason + ')');
    $form.find('button').toggleClass('submitted', false).prop('disabled', false);
  }

});

// Common scripts that run on all pages

umunandi.define('common', function() {

  // Normalise child heights, limited to < this elem's height
  // Use min-height to work out which item is tallest, then use height to fix the item
  // heights as .prev and .next are absolutely positioned and therefore need abs height.
  umunandi.normaliseHeights = function(elems) {
    $(elems).each(function() {
      var params = $(this).data('normaliseHeights');
      var selector = typeof params === 'object' ? params.elements : params;
      var items = $(selector, this);
      if (items.length === 0 || $(this).height() === 0) return; // Bail if no items or elem height = 0

      var maxH = 0;
      items.css({ 'min-height': '', 'height': '' }); // reset all heights
      items.each(function () { maxH = Math.max(maxH, $(this).outerHeight()); });
      if (maxH > 0) {
        items.css(params.minHeight ? 'min-height' : 'height', maxH + 'px');
        items.css(params.minHeight ? 'min-height' : 'height', $(this).innerHeight() + 'px');
      }
    });
  }

  // Show that a container is scrollable
  umunandi.isScrollable = function(selector) {
    $(selector).each(function() {
      $(this).toggleClass('can-scroll', this.scrollHeight - $(this).innerHeight() > 2);
    });
  }

  $(window).on('resize orientationchange', function () {
    umunandi.normaliseHeights('[data-normalise-heights]');
    umunandi.isScrollable('[data-is-scrollable]');
  }).resize();

  // TODO : IE image cover fit polyfill
  // https://medium.com/@primozcigler/neat-trick-for-css-object-fit-fallback-on-edge-and-other-browsers-afbc53bbb2c3

});

umunandi.define('common', 5, function() {

  // JS media queries
  umunandi.screenSize = {

    // copied from src/core/less/variables.less
    sizes: {
      xs: 480,
      sm: 768,
      md: 992,
      lg: 1200
    },

    getSize: function(size) {
      if (size in umunandi.screenSize.sizes) return umunandi.screenSize.sizes[size];
      if (isNaN(size)) return 1;
      return size;
    },

    isAtLeast: function(size) {
      return window.matchMedia('(min-width: ' + this.getSize(size) + 'px)').matches;
    },

    isUpTo: function(size) {
      return window.matchMedia('(max-width: ' + (this.getSize(size) - 1) + 'px)').matches;
    },

    updateSizes: function() {
      this.isAtLeastXs = this.isAtLeast('xs');
      this.isAtLeastSm = this.isAtLeast('sm');
      this.isAtLeastMd = this.isAtLeast('md');
      this.isAtLeastLg = this.isAtLeast('lg');
    }
  };
  
});

// Navigation related scripts

umunandi.define('common', function() {

  // Track navbar position to control floating/fixed state
  var navBar = {};
  navBar.el = $('.js-main-nav');
  navBar.refEl = $('.js-main-nav-position-ref');
  navBar.height = navBar.el.height();

  function onResize() {
    umunandi.screenSize.updateSizes();
    navBar.refElTop = navBar.refEl.offset().top;
  }
  $(window).on('resize orientationchange', $.debounce(100, onResize));
  onResize();

  function onScroll() {
    navBar.el.toggleClass('fixed', $(this).scrollTop() > navBar.refElTop);
  }
  $(document).on('scroll.umunandi', onScroll);
  onScroll();

  // Intercept scrollTo() calls - adjust the scroll end point to account for fixed navBar
  $.Animation.prefilter(function(el, props, opts) {
    if (el === window && 'scrollTop' in props && umunandi.screenSize.isAtLeastSm)
      props.scrollTop -= navBar.height;
  });

  // ScrollTo behaviour
  $('[data-scrollto]').off().on('click', function (e) {
    e.preventDefault();
    $('.nav-toggle-checkbox').prop('checked', false); // Close mobile menu
    var scrollOpts = {
      duration: parseInt(this.dataset.scrollto),
      offset: parseInt(this.dataset.scrolloffset)
    };
    $.scrollTo(this.dataset.scrollhref || $(this).attr('href'), scrollOpts);
  });

  // Globally limit javascript click actions
  $('a[href="#"]').click(function(e) { e.preventDefault(); });  

});

// People scripts
umunandi.define('people', function () {

  var $modal    = $('#people-modal');
  var $carousel = $('#people-carousel');

  // Initialise the modal: show it (off-screen), normalise carousel heights,
  // set scrollable class, then hide it again.
  function modalInit() {
    $modal.addClass('modal-init');
    umunandi.normaliseHeights($carousel.find('.carousel-inner'));
    $curItem = $carousel.find('.item.active');
    $carousel.find('.item').removeClass('active').each(function() {
      $(this).addClass('active');
      umunandi.isScrollable($(this).find('[data-is-scrollable]'));
      $(this).removeClass('active');
    });
    $curItem.addClass('active');
    $modal.removeClass('modal-init');
  }

  function showPerson() {
    if (!location.hash) return;
    $carousel.carousel($(location.hash).index());
    if (!($modal.data('bs.modal') && $modal.data('bs.modal').isShown)) $modal.modal('show');
  }

  function clearPerson() {
    history.replaceState("", document.title, location.pathname + location.search);
  }

  $modal
    .on('shown.bs.modal', function() { $('.carousel-control.right').focus(); })
    .on('hidden.bs.modal', clearPerson);

  $(window)
    .on('resize orientationchange', modalInit)
    .on('hashchange', showPerson)
    .trigger('resize')
    .trigger('hashchange');

});

// Home page scripts
umunandi.define('home', function () {

});

umunandi.define('sponsor', function () {

	// Construct sponsorship options list
	var $sponsorOpts     = $('.sponsor-options');
	var $sponsorOptRadio = $sponsorOpts.find('input').detach();
	$('.price-box-header').each(function(i, el) {
		$(el).clone()
			.prepend($sponsorOptRadio.clone().val(el.dataset.product))
			.find('h3').remove().end()
			.appendTo($sponsorOpts);
	});

	// Click handlers for selecting the sponsorship product
	// trigger(change) fires the radio change event (should happen implicitly IMO)
	// trigger(blur) is there to hook the form validation for the radio buttons
	$('.price-boxes, .sponsor-options').on('click', '.price-box, .price-box-header', function() {
		$('input[value="' + this.dataset.product + '"]').prop('checked', true).trigger('change').trigger('blur');
	});

	// Sponsor option radio buttons onChange handler - delegated to
	// parent element as radio buttons are dynamically generated
	$sponsorOpts.on('change', 'input', function () {
		$('.sponsor-options-product').text(this.value);
		$('.sponsor-options-price').html('for ').append($(this).nextAll('.price-box-price').clone().children());
		$(document).scrollTo('.sponsor-sign-up', 500, {
			offset: 10,
			onAfter: function () { $('input#firstName').focus(); }
		});
	});

});
